# 📘 8086 汇编入门 —— `[bx]` 和 `loop` 指令

---

## 5.1 `[bx]` —— 通过寄存器间接寻址

### 1️⃣ `[0]` 与 `[bx]` 的本质

* `[0]`
  表示一个**内存单元**

  * 偏移地址 = `0`
  * 段地址 = **默认在 DS 中**

* `[bx]`
  也表示一个**内存单元**

  * 偏移地址 = `BX`
  * 段地址 = **默认在 DS 中**

👉 本质统一公式：

```
物理地址 = DS × 16 + 偏移地址
```

---

### 2️⃣ `[bx]` 取字还是取字节？

⚠️ **不是由 `[bx]` 决定的，而是由目标寄存器决定**

| 指令            | 访问大小             |
| ------------- | ---------------- |
| `mov al,[bx]` | 取 1 字节           |
| `mov ah,[bx]` | 取 1 字节           |
| `mov ax,[bx]` | 取 1 个 word（2 字节） |

📌 `[bx]` 只是提供**地址**，
📌 **寄存器位数决定访问的数据大小**

---

### 3️⃣ `inc` 指令补充

```asm
inc bx
```

* 功能：`BX = BX + 1`
* 类似 C 语言中的 `++`
* **不会影响 CF 标志位**

---

## 5.2 `loop` 指令

### 1️⃣ 指令格式

```asm
loop 标号
```

### 2️⃣ CPU 执行 `loop` 时的两步操作

```text
1. CX = CX - 1
2. 如果 CX ≠ 0 → 跳转到标号
   如果 CX = 0 → 顺序向下执行
```

📌 `loop` **只能使用 CX 寄存器**

---

### 3️⃣ `loop` 的常见用途

* 实现循环结构
* CX 中存放 **循环次数**

---

### 4️⃣ 标号（Label）

* 标号代表一个**地址**
* 标号本身 **不占内存**
* 用来指示跳转目标位置

示例：

```asm
S:
    add ax,bx
```

---

### 5️⃣ 使用 `cx + loop` 的三个要点（⚠️重点）

1. **CX 中存放循环次数**
2. `loop` 指令中的标号必须在 **前面**
3. 循环体必须写在 **标号和 loop 指令之间**

---

### 6️⃣ 循环程序的标准框架

```asm
mov cx,循环次数
S:
    循环执行的程序段
loop S
```

---

## 5.3 在 Debug 中跟踪 `loop` 实现的循环

### ⚠️ 数值书写规则（非常重要）

在汇编程序中：

* **数字不能以字母开头**
* 如 `FFFFH` → ❌
* 正确写法：`0FFFFH` ✅

---

### Debug 常用命令

#### 1️⃣ `G` 命令（Go）

* `G`
  👉 一直执行，直到程序结束
* `G 地址`
  👉 执行到 `IP = 地址` 时暂停

---

#### 2️⃣ `T` 与 `P` 命令

| 命令  | 作用              |
| --- | --------------- |
| `T` | 单步进入（Step Into） |
| `P` | 单步通过（Step Over） |

---

## 5.4 Debug 与 MASM 对指令的不同处理

### 1️⃣ 在 Debug 中

```asm
mov ax,[0]
```

👉 合法，表示：

```
AX = DS:[0]
```

---

### 2️⃣ 在 MASM 中（⚠️易错点）

```asm
mov ax,[0]
```

会被当成：

```asm
mov ax,0
```

⚠️ **不是取内存，而是立即数！**

---

### 3️⃣ 正确写法（MASM）

✅ 明确段前缀：

```asm
mov ax,ds:[0]
```

✅ 或使用寄存器间接寻址：

```asm
mov bx,0
mov ax,[bx]        ; 等价于 mov ax,ds:[bx]
```

---

## 5.5 `loop` 和 `[bx]` 的联合应用

### 题目

**计算 `FFFF:0 ~ FFFF:B` 单元中 12 个字节数据的和，结果存入 DX**

---

### 问题分析

#### ⚠️ 问题 1：结果可能溢出 8 位

* 12 个 8 位数相加
* 结果可能 > 255
* **必须用 16 位寄存器保存**

#### ⚠️ 问题 2：8 位数据不能直接与 16 位相加

* `DX = DX + [BX]` ❌
* 类型不匹配

---

### 解决方案

👉 **先把 8 位数据扩展成 16 位，再相加**

---

### 示例代码（正确 & 规范）

```asm
assume cs:codesg

codesg segment
start:
    ; 指定数据段
    mov ax,0ffffh
    mov ds,ax

    ; 初始化
    mov ax,0
    mov dx,0
    mov bx,0

    ; 循环 12 次
    mov cx,0ch

circ:
    mov al,[bx]     ; 将 8 位数据放入 AL
                    ; AX 变成 0000~00FF 的 16 位数
    add dx,ax       ; 累加到 DX
    inc bx          ; 偏移地址 +1
    loop circ

    ; 程序返回
    mov ax,4c00h
    int 21h
codesg ends

end start
```

---

## 5.6 段前缀（Segment Override Prefix）

### 1️⃣ 默认规则

```asm
mov ax,[bx]
```

* 偏移地址：BX
* 段地址：**DS（默认）**

---

### 2️⃣ 显式指定段前缀

```asm
mov ax,ds:[0]
mov ax,ds:[bx]
```

📌 这里的 `ds:` 就叫 **段前缀**

⚠️ 常见段前缀还有：`cs:`、`ss:`、`es:`

---

## 5.7 一段“安全的空间”

### 1️⃣ 为什么要注意？

在 8086 实模式下：

* **可以随意访问任何内存**
* 但可能覆盖：

  * 系统数据
  * 中断向量表
  * 程序代码

👉 非常危险 ⚠️

---

### 2️⃣ 相对安全的内存区域

在 DOS 环境下：

```
0:200 ~ 0:2FF
```

* 共 256 字节
* 一般不被 DOS 和正规程序使用
* 适合做**实验、测试**

---

## ✅ 本章核心总结

* `[bx]` = DS 段中偏移为 BX 的内存单元
* 访问字 / 字节由 **目标寄存器位数决定**
* `loop` = `cx-- + 条件跳转`
* MASM 中必须明确内存访问方式
* 8 位数据参与运算，**要先扩展为 16 位**
* 实模式下写内存要考虑 **安全区域**

---
