# 📘 8086 汇编入门 —— 包含多个段的程序

---

## 6.1 在代码段中使用数据

### 1️⃣ `dw` 的含义

```asm
dw = define word
```

👉 **定义 1 个 word = 16 位 = 2 字节**

---

### 2️⃣ `dw` 出现在哪个段，数据就属于哪个段

| 出现位置            | 数据属于 |
| --------------- | ---- |
| `data segment`  | 数据段  |
| `code segment`  | 代码段  |
| `stack segment` | 栈段   |

📌 `dw` 只是申请内存并初始化
📌 **不决定用途，段决定用途**

---

### 3️⃣ `start` 标号 + `end start`

```asm
start:
    ...
end start
```

作用有两个：

1. **告诉编译器：程序的入口地址**
2. **告诉链接器：程序从哪里开始执行**

⚠️ 如果不写 `start`：

* 编译器默认从**第一个段的第一条指令**执行
* 第一个段不是代码段 → 程序直接出错

---

## 6.2 在代码段中使用栈

### 1️⃣ 栈的典型用途

⚠️ **题目出现“逆序”两个字，第一反应就该想到：栈（FILO）**

* 栈 = 后进先出（Last In First Out）
* 非常适合：

  * 逆序存放
  * 临时保存数据
  * 子程序返回地址

---

### 2️⃣ 用 `dw` 申请栈空间

```asm
stack segment
    dw 0,0,0,0,0,0,0,0
stack ends
```

* 每个 `dw` = 2 字节
* 共申请 16 字节栈空间
* 栈顶由 `SS:SP` 控制

⚠️ **8086 栈以 word 为单位操作**

---

## 6.3 将数据、代码、栈放入不同的段

### 1️⃣ 为什么要分段？

如果把所有东西都放在一个段中：

* ❌ 程序结构混乱
* ❌ 数据多 / 栈大时可能超过 64KB

⚠️ **8086 中一个段最大只能 64KB**

---

### 2️⃣ 多段程序的基本思想

| 段类型 | 常用名称    |
| --- | ------- |
| 数据段 | `data`  |
| 代码段 | `code`  |
| 栈段  | `stack` |

⚠️ **段名是给人看的，不是给 CPU 看的**

---

### 3️⃣ `assume` 的真正作用（⚠️重点）

```asm
assume cs:code, ds:data, ss:stack
```

* **assume 是伪指令**
* 只给 **汇编器** 看
* **CPU 完全不知道 assume 的存在**

❌ assume ≠ 设置寄存器
✅ assume = 告诉编译器“你应该这样理解代码”

---

### 4️⃣ 真正让 CPU 识别段的方法

👉 **必须使用机器指令**

```asm
mov ax,data
mov ds,ax

mov ax,stack
mov ss,ax
```

📌 **只有汇编指令，CPU 才会执行**

---

### 5️⃣ 为什么 `assume` 不可省略？

⚠️ 没有 `assume`：

* 编译器不知道你想用哪个段
* 会出现：

  * 编译错误
  * 隐式使用错误段
  * 难以排查的 bug

👉 **assume 是“让程序可读、可维护”的关键**

---

## 【实验五】关键结论总结

---

### 1️⃣ 段的实际占用空间（⚠️重要）

如果段中数据占 `N` 字节：

```
实际占用空间 =
N % 16 == 0 ? N : 16 × (N / 16 + 1)
```

📌 原因：

* 段的起始地址必须是 **16 字节对齐**
* 一个段最少占 16 字节

---

### 2️⃣ 调换段顺序的影响

* 段在内存中的排列顺序会改变
* CS / DS / SS 的值 **可能不同**
* 但程序逻辑不一定变（如果初始化正确）

---

### 3️⃣ 去掉 `start` 的后果

* 第一个段是代码段 → 可能还能跑
* 第一个段不是代码段 → 程序错误

👉 **规范写法必须有入口标号**

---

## 实验示例 1：数据段 + 栈段 + 代码段

### 功能

👉 使用栈交换 data 段中两个 word

```asm
assume cs:code,ds:data,ss:stack

data segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
    dw 0,0,0,0,0,0,0,0
stack ends

code segment
start:
    ; 初始化栈
    mov ax,stack
    mov ss,ax
    mov sp,16

    ; 初始化数据段
    mov ax,data
    mov ds,ax

    ; 使用栈交换数据
    push ds:[0]
    push ds:[2]
    pop ds:[2]
    pop ds:[0]

    mov ax,4c00h
    int 21h
code ends
end start
```

---

## 实验示例 2：a + b → data（多段访问）

### 功能

👉 a 段 + b 段，对应字节相加，结果存入 data 段

⚠️ 这里 **SS 被当作普通段寄存器使用**（教学演示）

```asm
assume cs:code

a segment
    db 1,2,3,4,5,6,7,8
a ends

b segment
    db 1,2,3,4,5,6,7,8
b ends

data segment
    db 0,0,0,0,0,0,0,0
data ends

code segment
start:
    mov bx,0
    mov al,0

    mov dx,a
    mov ss,dx

    mov dx,b
    mov es,dx

    mov dx,data
    mov ds,dx

    mov cx,8
circ:
    add al,ss:[bx]
    add al,es:[bx]
    mov [bx],al
    inc bx
    mov al,0
    loop circ

    mov ax,4c00h
    int 21h
code ends
end start
```

📌 实战中 **不建议滥用 SS**，这里只是为了演示多段访问

---

## 实验示例 3：利用栈逆序存放（⚠️经典）

### 功能

👉 将 a 段前 8 个 word 逆序存入 b 段

```asm
assume cs:code

a segment
    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
a ends

b segment
    dw 0,0,0,0,0,0,0,0
b ends

code segment
start:
    mov ax,a
    mov ss,ax
    mov sp,16

    mov ax,b
    mov ds,ax

    mov bx,0
    mov cx,8

circ:
    pop [bx]
    add bx,2
    loop circ

    mov ax,4c00h
    int 21h
code ends
end start
```

📌 **栈 = 天然逆序工具**

---

## ✅ 本章核心记忆点

* `dw` = 16 位（2 字节）
* 段名是给人看的，寄存器才是 CPU 认的
* `assume` 给编译器看，`mov ds/ss` 给 CPU 看
* 多段程序必须初始化 DS / SS
* 逆序存放 → 用栈
* 一个段最大 64KB，最小 16 字节