# 📘 8086 汇编入门 —— 寄存器与内存访问

---

## 3.1 内存中字的存储

### 基本概念

1. **任意两个连续的内存单元**（N 和 N+1）：

   * 可以看作 **两个独立的字节单元**
   * 也可以合起来看作 **一个字单元（word）**，地址为 N

2. **8086 使用小端存储（Little Endian）**

⚠️ **这是重点，必须牢牢记住**

* **低位字节 → 低地址**
* **高位字节 → 高地址**

例如：

```
4E20H
```

| 地址  | 内容       |
| --- | -------- |
| N   | 20H（低字节） |
| N+1 | 4EH（高字节） |

📌 **书写顺序 ≠ 内存存放顺序**

---

## 3.2 DS 和 `[address]`

### DS 寄存器的作用

1. **DS（Data Segment）**

   * 通常存放 **数据段的段地址**
   * `[address]` 中的 `address` 是 **偏移地址**

2. **物理地址计算规则**

```
物理地址 = DS × 16 + 偏移地址
```

---

### 示例：读取内存 10000H 的数据

```asm
mov bx, 1000H
mov ds, bx
mov al, [0]
```

📌 含义：

* DS = 1000H
* 偏移 = 0
* 实际访问地址：`1000H:0` → `10000H`

---

### mov 指令的内存访问能力

#### 已学过的 mov 传送形式

1. `mov 寄存器, 立即数`
2. `mov 寄存器, 寄存器`

#### 新增（非常重要）

3. `mov 寄存器, 内存单元`
4. `mov 内存单元, 寄存器`

📌 说明：

* `[xxx]` 表示 **偏移地址**
* **段地址默认来自 DS**

---

### ⚠️ 为什么不能 `mov ds, 1000H`？

❌ 非法指令

原因：

* **8086 不支持立即数 → 段寄存器**

✅ 正确做法（两步）：

```asm
mov bx, 1000H
mov ds, bx
```

👉 规则总结：

> **立即数 → 通用寄存器 → 段寄存器**

---

### 练习：把 AL 的数据写入 10000H

```asm
mov bx, 1000H
mov ds, bx
mov [0], al
```

---

## 3.3 字的传送（Word Transfer）

1. **8086 是 16 位 CPU**

   * 数据总线宽度：16 位
   * 一次可传送 **一个字（16 位）**

2. 示例：

```asm
mov bx, 1000H
mov ds, bx
mov ax, [0]      ; 读一个字
mov [0], cx      ; 写一个字
```

📌 实际访问内存：

* `[0]` 和 `[1]` 两个字节

---

## 3.4 mov / add / sub 指令总结

### mov 指令形式（完整）

| 形式            | 寻址方式  |
| ------------- | ----- |
| mov 寄存器, 立即数  | 立即寻址  |
| mov 寄存器, 寄存器  | 寄存器寻址 |
| mov 寄存器, 内存   | 直接寻址  |
| mov 内存, 寄存器   | 直接寻址  |
| mov 段寄存器, 寄存器 | 寄存器寻址 |
| mov 寄存器, 段寄存器 | 寄存器寻址 |

⚠️ **没有** `mov 内存, 内存`

---

### add / sub 指令

* **两个操作数**
* 结果一定回到 **第一个操作数**

#### add 示例

```asm
add ax, 1
add ax, bx
add ax, [0]
add [0], ax
```

#### sub 示例（不带借位）

```asm
sub ax, 1
sub ax, bx
sub ax, [0]
sub [0], ax
```

📌 语义：

```
op1 = op1 - op2
```

---

## 3.5 数据段（Data Segment）

* **数据段不是 CPU 自动区分的**
* 是程序员的逻辑安排

### 访问步骤总结

1. 将数据段段地址送入 DS
2. 使用 `[偏移地址]` 访问数据

👉 **DS 决定“哪一段”**
👉 **偏移决定“哪一个单元”**

---

## 3.6 栈（Stack）

### 栈的基本特性

* **后进先出（LIFO）**
* 8086 提供专门指令支持

### 栈相关指令

```asm
push ax
pop ax
```

📌 特点：

* **以字（16 位）为单位**
* push / pop 可在寄存器与内存之间传送

---

### 栈相关寄存器（极重要）

| 寄存器 | 作用     |
| --- | ------ |
| SS  | 栈段段地址  |
| SP  | 栈顶偏移地址 |

📌 任意时刻：

```
SS:SP → 栈顶
```

---

### push / pop 的执行过程

#### push ax

1. `SP = SP - 2`
2. `AX → SS:SP`

#### pop ax

1. `SS:SP → AX`
2. `SP = SP + 2`

⚠️ **pop 不会清空内存**

* 只是 SP 改了
* 下次 push 会覆盖

---

### 栈空时 SP 指向哪里？

* 指向 **最高地址单元的下一个单元**
* 即：逻辑上“还没入栈”

---

## 3.7 栈顶超界问题（⚠️重点）

1. **8086 不检查栈是否越界**
2. 栈越界场景：

   * 栈空时 pop
   * 栈满时 push

⚠️ 后果：

* 覆盖数据
* 覆盖代码
* 程序直接崩溃

👉 **这是严重错误，CPU 不帮你兜底**

---

## 3.8 栈段（Stack Segment）

1. 栈段是**程序员的逻辑定义**
2. SS:SP 指向当前栈顶
3. 栈最大容量：**64KB**

### 栈“环绕”问题（⚠️）

* SP 范围：`0000H ~ FFFFH`
* SP 减到 0 再减 → 回到 FFFEH
* 会覆盖旧栈内容

---

### 一个非常重要的总结（必背）

✅ 可以用 `mov` 直接修改：

```
SP
```

❌ 不能用 `mov` 直接修改：

```
CS IP SS DS
```

正确规则：

| 寄存器     | 修改方式             |
| ------- | ---------------- |
| CS / IP | JMP / CALL / RET |
| SS / DS | mov 段寄存器, 通用寄存器  |
| SP      | mov sp, 立即数      |

---

## 总结

> **8086 不理解“代码 / 数据 / 栈”，
> 它只看 CS:IP、DS、SS:SP 的设置。**
